# 1.两数之和

**遍历数组**

```c
int* twoSum(int* nums, int numsSize, int target, int* returnSize)
{
	for (int x; x < numsSize; x++)
	{
		for (int y=x+1; y < numsSize; y++)
		{
			if (nums[x] + nums[y] == target)
			{
				int* a = malloc(sizeof(int) * 2);//申请两个int大小的内存。这条语句等价于 int a[2];
                                                   //但是这是在自定义函数中，如果用int a[2]，内存则会从栈中获取，会警告                                                     // 这条语句就是从堆里获取，不会给警告
				a[0] = x;
				a[1] = y;
				*returnSize = 2;
				return a;
			}
		}
	}
	*returnSize = 0;
	return NULL;
}
```

**哈希表**

```c
typedef struct
{
    int val;
    int key;
    UT_hash_handle hh;
}map;

map* hashmap = NULL;//创建哈希表

void hashadd(int key, int val)
{
    map* s;
    HASH_FIND_INT(hashmap, &key, s);
    if (s == NULL)
    {
        s = (map*)malloc(sizeof(map));
        s->key = key;
        HASH_ADD_INT(hashmap, key, s);
    }
    s->val = val;
}

map* hashfind(int key)
{
    map* s;
    HASH_FIND_INT(hashmap, &key, s);//找到key则返回key所在结构的位置，未找到则范围NULL，s则是返回赋值的参数。
    return s;
}

int* twoSum(int* nums, int numsSize, int target, int* returnSize) {
    int i, * ans;
    hashmap = NULL;
    map* hash1;
    ans = malloc(sizeof(int) * 2);
    for (i = 0; i < numsSize; i++)
    {
        hashadd(nums[i], i);
    }
    for (i = 0; i < numsSize; i++)
    {
        hash1 = hashfind(target - nums[i]);
        if (hash1 != NULL)
        {
            ans[0] = hash1->val;
            ans[1] = i;
            *returnSize = 2;
            return ans;
        }
    }
    *returnSize = 0;
    return NULL;
}
```

此代码力扣有一个用例没通过，暂未找到原因

# 2.搜索插入位置

**二分查找**

```c
int searchInsert(int* nums, int numsSize, int target)
{
    int left, right, mid;
    left = 0, right = numsSize - 1;
    while (left <= right)
    {
        mid = (left + right) / 2;//int mid = ((right - left) >> 1) + left;两者等价，位运算更快
        if (target <= nums[mid])
        {
            right = mid - 1;
        }
        else
        {
            left = mid + 1;
        }
    }
    return left;
}
```

# 3.数组拆分（贪心）

![image-20231018174413481](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231018174413481.png)

先将数组进行从小到大排序，然后隔一个选取一个数。

因为要达到min总和最大，那么min(a,b)中的a,b必须是接近的。所以排完序的数组 两个一组，每组只选前面的a，那么b就可以忽略。每组的a求和就是答案

```c++
//c++
class Solution {
public:
    int arrayPairSum(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        int ans=0;
        for(int i=0;i<nums.size();i+=2)
        {
            ans+=nums[i];
        }
        return ans;
    }
};
```

```python
#python3
class Solution:
    def arrayPairSum(self, nums: List[int]) -> int:
        nums.sort()
        return sum(nums[::2])
```

```java
//java
class Solution {
    public int arrayPairSum(int[] nums) {
        Arrays.sort(nums);
        int ans=0;
        for(int i=0;i<nums.length;i+=2)
        {
            ans+=nums[i];
        }
        return ans;
    }
}
```

# 4.最长回文串（贪心）

![image-20231018182637123](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231018182637123.png)

回文串，正着读反着读相同的字符串。

如果字符个数为偶数，所有字符镜像对称。

如果字符个数为奇数，那么**只有一个**奇数字符，其他全为偶数字符。

所以先统计每个字符出现了多少次，那么就要用到**哈希表**。

键为字符，值为出现次数。

那么对哈希表中的值进行遍历，那么怎么进行处理呢？

​		出现偶数次数的字符都可以用来当回文串中的元素。

​		出现奇数次数的字符只能拿一个来当回文串中的元素。

​				也就是说，要判断是否是奇数，并在有一个奇数后拒绝后续奇数。

那么有以下代码。

```python
class Solution:
    def longestPalindrome(self, s: str) -> int:
        ans=0
        count=collections.Counter(s)
        for v in count.values():
            ans+=v//2*2#处理偶数字符和奇数字符。如果v=3，整除2后得1，再乘以2，得2，那么就有两个可以放进回文串两边
            			#后续if判断v为奇数，那么v-1为偶数，把v-1个字符放入两边(ans统计了)，剩下1个放中间，即							ans+=1
            if(ans%2==0 and v%2==1):#同时也要避免多个奇数进入，所以前面还要判断ans是否为偶数，是则ans中还未统计进出现次数为奇数的字符，否那么ans已经统计了一个出现次数为奇数的字符，就不进行ans+=1了。
                ans+=1
        return ans
```

其中collections模块值得学习。

[Python collections模块之Counter()详解_python counter-CSDN博客](https://blog.csdn.net/chl183/article/details/106956807)
