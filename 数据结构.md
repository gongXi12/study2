5.21

# 一.引言

图书馆排书->**解决问题方法的效率，也跟空间的利用效率是有关的。**

输入N，打印从1到N的所有整数，用递归（N足够大时，递归占用内存过多）或者循环->**解决问题方法的效率，也跟空间的利用效率是有关的。**

------

**解决问题方法的效率，跟算法的巧妙程度有关。**

写程序计算一元多项式的值。

```c
double f(int n, double a[], double x)
{
	int i;
	double p = a[0];

	for (i = 1; i <= n; i++)
	{
		p += (a[i] * pow(x, i));
	}
	return p;

}
```

```c
double f(int n, double a[], double x)
{
	int i;
	double p = a[0];

	for (i = n; i > 0; i--)
	{
		p = a[i - 1] + x * p;
	}
	return p;

}
```

第二种算法快于第一种算法。第二种每一次把x当成一个公因子提出来，从里往外算。

# 二.时间复杂度和空间复杂度

空间复杂度S(n)，完成任务所需的空间

时间复杂度T(n)，完成任务所需要的时间

# 1.线性表

## 1.1线性表的定义和特点

线性表是具有相同特性的数据元素的一个有限序列。

![image-20230916171631406](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20230916171631406.png)

![image-20230916171716732](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20230916171716732.png)

同一线性表中的元素必定具有相同特性，数据元素间的关系是线性关系。



线性表的逻辑特征：

- 在非空的线性表，有且仅有一个开始结点a1，它没有直接前趋，而仅有一个直接后继a2；

- 有且仅有一个终端节点an，它没有直接后继，而仅有一个直接前趋an-1；

- 其余的内部节点都有且仅有一个直接前趋和一个直接后继。

  ------

  顺序存储结构存在问题：

​			存储空间分配不灵活

​			运算的空间复杂度高

##  1.2线性表的基本操作

![image-20230917211710680](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20230917211710680.png)

![image-20230917211946024](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20230917211946024.png)

![image-20230918230159243](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20230918230159243.png)

![image-20230918230413552](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20230918230413552.png)

![image-20230918230623493](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20230918230623493.png)

![image-20230918230755814](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20230918230755814.png)

要先确定线性表的存储结构再来确定如何来实现。

## 1.3线性表的存储结构

### 1.3.1线性表的顺序存储表示

顺序存储定义：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构。

![image-20230918231225856](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20230918231225856.png)

a1的地址，称为线性表的**起始位置**或**基地址**。

线性表顺序存储结构**占用一片连续的存储空间**。知道某个元素的存储位置就可以计算其他元素的存储位置。（中间不能空）

![image-20230918232046133](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20230918232046133.png)

上面是顺序表。

![image-20230918232636232](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20230918232636232.png)

![image-20230919121648826](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20230919121648826.png)

上面是C的，下面是C++的

![image-20230919122406666](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20230919122406666.png)

引用类型

![image-20230919123110341](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20230919123110341.png)

基本操作整理

![image-20230919124452359](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20230919124452359.png)

![image-20230919124522138](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20230919124522138.png)

## 1.4顺序表操作代码

```c++
#include<iostream>
using namespace std;

#define MAXSIZE 100
#define ElemType int
#define Status int
#define OK 1
#define ERROR 0

typedef struct 
{
	ElemType* elem;
	int length;
}Sqlist;

Status initList(Sqlist &L)
{
	L.elem = new ElemType[MAXSIZE];
	if (!L.elem)exit(OVERFLOW);
	L.length = 0;
	return OK;
}

void DestroyList(Sqlist& L)
{
	if (L.elem)delete L.elem;
}

void Clearlist(Sqlist& L)
{
	L.length = 0;
}

int GetLength(Sqlist& L)
{
	return (L.length);
}

int IsEmpty(Sqlist& L)
{
	if (L.length == 0)return 1;
	else return 0;
}

int GetElem(Sqlist& L, int i, ElemType& e)
{
	if (i<1 || i>L.length)return ERROR;
	e = L.elem[i - 1];
	return OK;
}

int LocateList(Sqlist& L, ElemType e)
{
	for (int i = 0; i < L.length; i++)
		if (L.elem[i] == e)return i + 1;
	return 0;
}

Status ListInsert_Sq(Sqlist& L, int i, ElemType e)
{
	if (i<1 || i>L.length + 1)return ERROR;
	if (L.length == MAXSIZE)return ERROR;
	for (int j = L.length - 1; j >= i - 1; j--)
		L.elem[j + 1] = L.elem[j];
	L.elem[i - 1] = e;
	L.length++;
	return OK;
}

Status ListDelete_Sq(Sqlist& L, int i)
{
	if (i<1 || i>L.length)return ERROR;
	for (int j = i; j <= L.length - 1; j++)
		L.elem[j - 1] = L.elem[j];//删除第i个元素，直接用第i+1个元素覆盖。
	L.length--;
	return OK;
}
```

## 1.5链表操作代码

![image-20231007113628661](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231007113628661.png)

```c++
#include<iostream>
using namespace std;

#define MAXSIZE 100
#define ElemType int
#define Status int
#define OK 1
#define ERROR 0

typedef struct Lnode
{
	ElemType data;
	struct Lnode* next;
}Lnode,*LinkList;

//初始化链表
Status InitList_L(LinkList& L)
{
	L = new Lnode;// L=(Linklist)malloc(sizeof(Lnode));
	L->next = NULL;
	return OK;
}

//判断是否为空链表
int ListEmpty(LinkList L)
{
	if (L->next)//不等于NULL
		return 0;//不是空链表
	else
		return 1;//是空链表
}

//单链表的销毁
Status DestroyList_L(LinkList& L)
{
	Lnode* p;//或者LinkList p;
	while (L)//不是空表
	{
		p = L;
		L = L->next;
		delete p;
	}
	return OK;
}

Status ClearList(LinkList& L)//L为头结点
{
	Lnode* p, *q;//或者LinkList p,q;
	p = L->next;
	while (p)
	{
		q = p->next;
		delete p;
		p = q;
	}
	L->next = NULL;
	return OK;
}

int ListLength_L(LinkList& L)
{
	LinkList q;
	q = L->next;
	int i = 0;
	while (q)
	{
		i++;
		q = q->next;
	}
	return i;
}

Status GetElem_L(LinkList L, int i, ElemType& e)
{
	LinkList p = L->next;
	int j = 1;
	while (p && j < i)
	{
		p = p->next, ++j;//++j的效率比j++高
	}
	if (!p || j > i) return ERROR;
	e = p->data;
	return OK;
}

Lnode* LocateElem_L(LinkList L, ElemType e)
{
	LinkList p = L->next;
	while (p&&p->data != e)
	{
		p = p->next;
	}
	return p;
}

LinkList LocateElem_L1(LinkList L, ElemType e)
{
	LinkList p = L->next;
	while (p && p->data != e)
	{
		p = p->next;
	}
	p = p->next;
	return p;
}

int LocateElem_L2(LinkList L, ElemType e)
{
	LinkList p = L->next;
	int j = 1;
	while (p && p->data != e)
	{
		p = p->next; ++j;
	}
	if (p) return j;//检测p是否为空，不为空那么就找到了。
	else return 0;//没找到
}

Status InsertElem(LinkList L, ElemType e, int i)
{
	LinkList p = L->next;
	int j = 0;
	while (j < i-1 && p)
	{
		p = p->next; ++j;
	}
	if (!p || j > i - 1)return ERROR;
	LinkList s = new Lnode;
	s->data = e;
	s->next = p->next;
	p->next = s;
	return OK;
}

Status DeleteElem(LinkList L, ElemType e, int i)
{
	LinkList p = L->next;
	int j = 0;
	while (j < i - 1 && p)
	{
		p = p->next; ++j;
	}
	if (!p || j > i - 1)return ERROR;
	LinkList q = p->next;//临时保存被删除结点的地址
	p->next = q->next;//改变被删除结点的前驱节点指向为被删除节点的后继结点
	e = q->data;//保存被删除结点的数据域。
	delete q;
	return OK;
}

Status GetElem(LinkList L, ElemType e, int i)
{
	LinkList p = L->next;
	int j = 1;
	while (p && j < i)
	{
		p = p->next; ++j;
	}
	if (!p || j > i)return ERROR;
	e = p->data;
	return OK;
}
```

### 1.5.1建立单链表的多种方法

**头插法--元素插入在链表头部**

**尾插法**

```c++
//头插法
void CreateListFirst(LinkList L, int n)
{
	L = new Lnode;
	L->next = NULL;
	for (int i = n; i > 0; --i)
	{
		LinkList p = new Lnode;
		cin >> p->data;
		p->next = L->next;
		L->next = p;
	}
}

//尾插法
void CreateListEnd(LinkList L, int n)
{
	L = new Lnode;
	L->next = NULL;
	LinkList r = L;
	for (int i = 0; i < n; ++i)
	{
		LinkList p = new Lnode;
		cin >> p->data;
		p->next = NULL;
		r->next = p;
		r = p;
	}
}
```

### 1.5.2循环链表的表示

![image-20231021111909834](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231021111909834.png)



```c++
//初始化循环链表
bool initList(LinkList L)
{
	L = new Lnode;
	if (L == NULL)return false;
	L->next = L;
	return true;
}

//链接两个带尾指针的循环链表
LinkList Connect(LinkList Ta, LinkList Tb)
{
	LinkList p = Ta->next;
	Ta->next = Tb->next->next;
	delete Tb->next;
	Tb->next = p;
	return Tb;
}
```

![image-20231022131245266](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231022131245266.png)

### 1.5.3双向链表

双向链表除了插入和删除操作和单链表不同外，其余都与单链表相同。

```c++
#include<iostream>
using namespace std;

#define MAXSIZE 100
#define ElemType int
#define Status int
#define OK 1
#define ERROR 0

typedef struct DuLnode
{
	ElemType data;
	struct DuLnode* prior, * next;
}DLnode,*LinkList;

//得到L中第i个结点的地址
LinkList GetElemP_DuL(LinkList L, int i)
{
	LinkList p = L->next;
	int j = 0;
	if (p && j < i)
	{
		p = p->next;
		++j;
	}
	return p;
}

//双向链表的插入
Status InsertElem_DL(LinkList L,ElemType e,int i)
{
	LinkList p = GetElemP_DuL(L, i);
	if (!p)return ERROR;
	LinkList s = new DLnode;
	s->data = e;
	s->prior = p->prior;
	s->next = p;
	p->prior = s;
	return OK;
}

//双向链表的删除
Status DleteElem_DL(LinkList L, ElemType e, int i)
{
	LinkList p = GetElemP_DuL(L, i);
	if (!p)return ERROR;
	e = p->data;
	p->prior->next = p->next;
	p->next->prior = p->prior;
	free(p);
	return OK;
}
```

![image-20231022164450660](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231022164450660.png)

------

## 1.6链表和顺序表的比较

![image-20231022165213592](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231022165213592.png)

![image-20231022164749314](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231022164749314.png)



![image-20231022165234066](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231022165234066.png)

## 1.7线性表的应用

### 1.7.1线性表的合并

```c++
void ListUnion(LinkList La, LinkList Lb)
{
	La_len = ListLength(La);
	Lb_len = ListLength(Lb);
	for (int i = 1; i <= Lb_len; ++i)
	{
		GetElem(Lb, i, e);
		if (!LocateElem(La, e)) InsertElem(&La, ++La_len, e);
	}
}
```

### 1.7.2有序表的合并

用顺序表实现。

```c++
//用顺序表实现
void SqListUnion(Sqlist La, Sqlist Lb,Sqlist &Lc)
{
	ElemType* pa, * pb, * pc, * pa_last, * pb_last;
	pa = La.elem;
	pb = La.elem;
	Lc.length = La.length + Lb.length;
	Lc.elem = new ElemType[Lc.length];
	pc = Lc.elem;
	pa_last = La.elem + La.length - 1;
	pb_last = Lb.elem + Lb.length - 1;
	while (pa <= pa_last && pb <= pb_last)
	{
		if (*pa <= *pb)
		{
			*pc++ = *pa++;
		}
		else
		{
			*pc++ = *pb++;
		}
	}
	while (pa <= pa_last)
	{
		*pc++ = *pa++;
	}
	while (pb <= pb_last)
	{
		*pc++ = *pb++;
	}
}
```

![image-20231023124445352](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231023124445352.png)

用链表实现。

```c++
//用链表实现
#include<iostream>
using namespace std;

#define MAXSIZE 100
#define ElemType int
#define Status int
#define OK 1
#define ERROR 0

typedef struct Lnode
{
	ElemType data;
	struct Lnode *next;
}Lnode, * LinkList;

void LnodeUnion(LinkList a, LinkList b, LinkList c)
{
	LinkList pa, pb, pc;
	pa = a->next;
	pb = b->next;
	pc = c = a;//用a的头结点作为c的头结点
	while (pa && pb)
	{
		if (pa->data <= pb->data)
		{
			pc->next = pa;
			pc = pa;
			pa = pa->next;
		}
		else
		{
			pc->next = pb;
			pc = pb;
			pb = pb->next;
		}
	}
	pc->next = pa ? pa : pb;//插入剩余段
	delete b;
}
```

![image-20231023125653067](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231023125653067.png)

# 2.栈和队列

栈和队列是限定插入和删除只能在表的“端点”进行的**线性表**。

![image-20231024130901123](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231024130901123.png)

**栈的特性--后进先出**

只能在队尾插入和删除。

栈的应用--如果求解的过程具有“后进先出”的天然特性的话，求解算法也会用到栈。

**队列的特性--先进先出**

只能在队尾插入，在队头删除。

------

## 2.1栈

![image-20231024131218287](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231024131218287.png)

![image-20231024131242875](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231024131242875.png)



![image-20231024131514991](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231024131514991.png)

### 2.1.1顺序栈

存储方式：同一般线性表的顺序存储结构完全相同。

附设**top**指针，指示栈顶元素在顺序栈中的位置。

另设**base**指针，指示栈底元素在顺序栈中的位置。

但是，为了方便操作，通常top指示真正的**栈顶元素之上**的下标地址。

另外，用stacksize表示栈可使用的最大容量。

![image-20231025182347034](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231025182347034.png)

![image-20231025182420263](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231025182420263.png)

```c++
#include<iostream>
using namespace std;

#define MAXSIZE 100
#define ElemType int
#define Status int
#define OK 1
#define ERROR 0
#define MAXSIZE 100
#define TRUE 1;
#define FALSE 0;

typedef struct SqStack
{
	ElemType* base;
	ElemType* top;
	int stacksize;
}SqStack;

Status InitStack(SqStack& s)
{
	s.base = new ElemType[MAXSIZE];
	if (!s.base)return ERROR;
	s.top = s.base;
	s.stacksize = MAXSIZE;
	return OK;
}

Status StackEmpty(SqStack s)
{
	if (s.top == s.base)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

int StackLength(SqStack s)
{
	return (s.top - s.base);
}

Status ClearStack(SqStack s)
{
	if (s.base)s.top = s.base;
	return OK;
}

Status DestroyStack(SqStack s)
{
	if (s.base)
	{
		delete s.base;
		s.stacksize = 0;
		s.base = s.top = NULL;
	}
	return OK;
}

Status Push(SqStack& s, ElemType e)
{
	if (s.top - s.base == s.stacksize)return ERROR;
	*s.top = e;
	++s.top;//等价为*s.top++=e;
	return OK;
}

Status Pop(SqStack& s,ElemType &e)
{
	if (s.top == s.base)return ERROR;
	--s.top;
	e = *s.top;//等价为e=*--s.top
	return OK;
}
```

### 2.1.2链栈

链栈是运算受限的单链表，只能在**链表头部**进行操作。

![image-20231025203355653](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231025203355653.png)

```c++
#include<iostream>
using namespace std;

#define MAXSIZE 100
#define ElemType int
#define Status int
#define OK 1
#define ERROR 0
#define MAXSIZE 100
#define TRUE 1;
#define FALSE 0;



//链栈
typedef struct StackNode
{
	ElemType data;
	struct StackNode* next;
}StackNode,*LinkStack;

Status InitStack(LinkStack s)
{
	//构造一个空栈，栈顶指针置为空
	s = NULL;
	return OK;
}

Status StackEmpty(LinkStack s)
{
	if (s == NULL)return TRUE;
	return FALSE;
}

Status Push(LinkStack s, ElemType e)
{
	LinkStack p = new StackNode;
	p->next = s;
	p->data = e;
	s = p;
}

Status Pop(LinkStack s, ElemType e)
{
	if (s == NULL)return ERROR;
	e = s->data;
	LinkStack p = s;
	s = s->next;
	delete p;
	return OK;
}

ElemType GetTop(LinkStack s)
{
	if (s != NULL)
		return s->data;
}
```

### 2.1.3栈与递归

递归的思想和栈非常相似，递归不断递归，类似于进栈，然后开始返回时，从最后一个返回。

后进先出。





## 2.2队列

![image-20231024131651686](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231024131651686.png)

![image-20231026112502586](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231026112502586.png)

### 2.2.1顺序队

![image-20231026112942600](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231026112942600.png)

![image-20231026112956906](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231026112956906.png)

![image-20231026113826825](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231026113826825.png)

![image-20231026113931044](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231026113931044.png)



```c++
#include<iostream>
using namespace std;

#define MAXSIZE 100
#define ElemType int
#define Status int
#define OK 1
#define ERROR 0
#define MAXSIZE 100
#define TRUE 1;
#define FALSE 0;


typedef struct
{
	ElemType* base;
	int front;//头(前)指针
	int rear;//尾(后)指针
}SqQueue;

Status InitQueue(SqQueue& q)
{
	q.base = new ElemType[MAXSIZE];
	if (!q.base) exit(ERROR);//存储分配失败;
	q.front = q.rear = 0;
	return OK;
}

int QueueLength(SqQueue q)
{
	return ((q.rear - q.front+MAXSIZE)%MAXSIZE);
}

Status EnQueue(SqQueue& q, ElemType e)
{
	if ((q.rear + 1) == MAXSIZE)return ERROR;
	q.base[q.rear] = e;
	q.rear = (q.rear + 1) % MAXSIZE;
	return OK;
}

Status DeQueue(SqQueue& q, ElemType e)
{
	if (q.front == q.rear)return ERROR;
	e = q.front;
	q.front = (q.front + 1) % MAXSIZE;
	return OK;
}

ElemType GetHead(SqQueue q)
{
	if (q.front != q.rear)
		return q.base[front];
}
```

求队列的长度需要特别注意：

![image-20231026114445908](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231026114445908.png)

### 2.2.2链队

![image-20231026130000535](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231026130000535.png)

```c++
#include<iostream>
using namespace std;

#define MAXSIZE 100
#define ElemType int
#define Status int
#define OK 1
#define ERROR 0
#define MAXSIZE 100
#define TRUE 1;
#define FALSE 0;


typedef struct Qnode
{
	ElemType data;
	struct Qnode* front, * rear;//这样定义对吗？
	struct Qnode* next;
}Qnode,*LinkQueue;

Status InitQueue(LinkQueue q)
{
	q->front = q->rear = new Qnode;
	if (!q->front) exit (ERROR);
	q->front->next = NULL;
	return OK;
}

//从队头结点开始释放结点
Status DestroyQueue(LinkQueue q)
{
	LinkQueue p;
	while (q->front)
	{
		p = q->front->next;
		free(q->front);
		q->front = p;
		/*q->rear = q->front->next;
		free(q->front);
		q->front = q->rear;*/
	}
	return OK;
}

Status EnQueue(LinkQueue q, ElemType &e)
{
	LinkQueue p = new Qnode;
	if (!p)exit(ERROR);
	p->data = e;
	p->next = NULL;
	q->rear->next = p;
	q->rear = p;
	return OK;
}

Status DeQueue(LinkQueue q, ElemType &e)
{
	if (q->rear == q->front)return ERROR;
	LinkQueue p = new Qnode;
	p = q->front->next;
	e = p->data;
	q->front->next = p->next;
	if (q->rear == p)q->rear = q->front;
	delete p;
	return OK;
}

Status GetHead(LinkQueue q, ElemType &e)
{
	if (q->front == q->rear)return ERROR;
	e = q->front->next->data;//这里为什么不是*e
	return OK;
}
```

# 3.串、数组和广义表

## 3.1串

串（String）--零个或多个任意**字符组成的有限序列**

![image-20231028112839391](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231028112839391.png)

子串：串中任意个连续字符组成的**子序列**（含空串）称为该串的子串。

真子串：是指不包含自身的所有**字串**。

主串：包含子串的串相应地称为**主串**。

字符位置：字符**在序列中的序号**为该字符在串中的位置。

子串位置：**子串中第一个字符**在主串中的位置。

空格串：由一个或多个空格组成的串，**与空串不同**。



串相等：当且仅当两个串的长度相等并且各个对应位置上的字符都相同时，这两个串才是相等的。

所有空串都是相等的。

### 3.1.1顺序串









### 3.1.2块链

![image-20231028114804160](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231028114804160.png)

### 3.1.3串的模式匹配算法

#### 3.1.3.1BF算法

Brute-Force

简单匹配算法，穷举法。

![image-20231028120647991](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231028120647991.png)

![image-20231029102309957](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231029102309957.png)

![image-20231029102419810](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231029102419810.png)

```c++
int Index_BF(SString S, SString T, int pos)
{
	int i = pos;
	int j = 1;
	while (i <= S.length && j <= T.length)
	{
		if (S.ch[i] == T.ch[j])
		{
			++i;
			++j;
		}
		else//回溯重新开始下一次匹配
		{
			i = i - j + 2;
			j = 1;
		}
	}
	if (j >= T.length)return i - T.length;//返回匹配的第一个字符的下标
	else return 0;//不成功
}
```

![image-20231029103841961](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231029103841961.png)

#### 3.1.3.2KMP算法

算法效率比BF算法高。

利用已经部分匹配的结果而加快模式串的滑动速度，且主串S的指针**不必回溯**，可提速到**O(n+m)**

![image-20231105112713444](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231105112713444.png)

![image-20231105112730805](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231105112730805.png)



[最浅显易懂的 KMP 算法讲解_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1AY4y157yL/?spm_id_from=333.337.search-card.all.click&vd_source=3580a91ef2d3a4435b301ae3cbe67957)





## 3.2数组

![image-20231029104324940](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231029104324940.png)

![image-20231029104403262](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231029104403262.png)

![image-20231029104431196](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231029104431196.png)

### 3.2.1数组的顺序存储

![image-20231029104638851](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231029104638851.png)

![image-20231105113403109](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231105113403109.png)

![image-20231105113445352](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231105113445352.png)

### 3.2.2特殊矩阵的压缩存储

![image-20231105113832208](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231105113832208.png)

![image-20231105113952011](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231105113952011.png)

![image-20231105114040801](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231105114040801.png)

![image-20231105114438776](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231105114438776.png)

![image-20231105114521458](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231105114521458.png)

![image-20231105114710346](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231105114710346.png)

![image-20231105115933765](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231105115933765.png)

![image-20231106131643647](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231106131643647.png)

![image-20231106131831165](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231106131831165.png)

### 3.3广义表

![image-20231106132013032](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231106132013032.png)

![image-20231106132049844](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231106132049844.png)

![image-20231106132222494](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231106132222494.png)

![image-20231106132320524](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231106132320524.png)

![image-20231106132455007](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231106132455007.png)

# 4.树和二叉树

![image-20231106132834438](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231106132834438.png)

![image-20231106133038580](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231106133038580.png)

![image-20231107174310219](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231107174310219.png)

![image-20231107174328163](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231107174328163.png)

![image-20231107180908447](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231107180908447.png)

![image-20231107181237730](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231107181237730.png)

![image-20231107181721183](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231107181721183.png)

![image-20231107181804745](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231107181804745.png)

![image-20231107181808772](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231107181808772.png)

![image-20231107181840749](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231107181840749.png)

![image-20231107182036560](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231107182036560.png)

![image-20231109102141664](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231109102141664.png)

![image-20231109102301705](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231109102301705.png)

![image-20231111153339943](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231111153339943.png)

![image-20231111154911612](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231111154911612.png)

![image-20231112111640193](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231112111640193.png)

![image-20231112112731712](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231112112731712.png)

![image-20231112113744085](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231112113744085.png)

## 4.1二叉树的遍历

### 4.1.1递归先中后序遍历

### 4.1.2非递归中序遍历

![image-20231113124911006](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231113124911006.png)

```c++
#include<iostream>
using namespace std;

#define MAXLEN 255
#define CHUNKSIZE 80//块的大小可自定义
#define ElemType BiTree
#define Status int
#define OK 1
#define ERROR 0
#define MAXSIZE 100
#define TRUE 1;
#define FALSE 0;
#define MAXTSIZE 100
#define TElemType int

typedef struct SqStack
{
	ElemType* base;
	ElemType* top;
	int stacksize;
}SqStack;

Status InitStack(SqStack& s)
{
	s.base = new ElemType[MAXSIZE];
	if (!s.base)return ERROR;
	s.top = s.base;
	s.stacksize = MAXSIZE;
	return OK;
}

Status Push(SqStack& s, ElemType e)
{
	if (s.top - s.base == s.stacksize)return ERROR;
	*s.top = e;
	++s.top;//等价为*s.top++=e;
	return OK;
}

Status Pop(SqStack& s, ElemType& e)
{
	if (s.top == s.base)return ERROR;
	--s.top;
	e = *s.top;//等价为e=*--s.top
	return OK;
}

Status StackEmpty(SqStack s)
{
	if (s.top == s.base)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}




typedef TElemType SqBiTree[MAXTSIZE];//Binary Tree
SqBiTree bt;

typedef struct BTNode
{
	TElemType data;
	struct BTNode* lchild, * rchild;
}*BiTree;

typedef struct ThTNode
{
	TElemType data;
	struct ThTNode* lchild, * parent, * rchild;
};

//-----------------------------------------------递归遍历-------------------------------//

//前序遍历
Status PreOrderTraverse(BiTree T)
{
	if (T == NULL)return OK;
	else
	{
		cout << T->data;
		PreOrderTraverse (T->lchild);
		PreOrderTraverse (T->rchild);
	}
}

//中序遍历
Status InOrderTraverse(BiTree T)
{
	if (T == NULL)return OK;
	else
	{
		PreOrderTraverse(T->lchild);
		cout << T->data;
		PreOrderTraverse(T->rchild);
	}
}

//后序遍历
Status PostOrderTraverse(BiTree T)
{
	if (T == NULL)return OK;
	else
	{
		PreOrderTraverse(T->lchild);
		PreOrderTraverse(T->rchild);
		cout << T->data;
	}
}

//-----------------------------------------------非递归遍历-----------------------------//
//以中序为例
Status InOrderTraverse(BiTree T)
{
	BiTree p,q;
	SqStack s;
	InitStack(s);
	p = T;
	while (p || !StackEmpty(s))
	{
		if (p)
		{
			Push(s,p);
			p = p->lchild;
		}
		else
		{
			q = p;
			Pop(s, q);
			cout << p->data << endl;
			p = q->rchild;
		}
	}
	return OK;
}
```

![image-20231113135016376](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231113135016376.png)

### 4.1.3分层遍历

![image-20231114121943072](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231114121943072.png)

![image-20231114163954178](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231114163954178.png)

```c++
#include<iostream>
using namespace std;

#define MAXSIZE 100
#define TElemType BiTree
#define ElemType int
#define Status int
#define OK 1
#define ERROR 0
#define MAXSIZE 100
#define TRUE 1;
#define FALSE 0;

typedef struct
{
	TElemType* base;
	int front;//头(前)指针
	int rear;//尾(后)指针
}SqQueue;

Status InitQueue(SqQueue& q)
{
	q.base = new TElemType[MAXSIZE];
	if (!q.base) exit(ERROR);//存储分配失败;
	q.front = q.rear = 0;
	return OK;
}

Status EnQueue(SqQueue& q, TElemType e)
{
	if ((q.rear + 1) == MAXSIZE)return ERROR;
	q.base[q.rear] = e;
	q.rear = (q.rear + 1) % MAXSIZE;
	return OK;
}

Status DeQueue(SqQueue& q, TElemType e)
{
	if (q.front == q.rear)return ERROR;
	e = q.base;
	q.front = (q.front + 1) % MAXSIZE;
	return OK;
}

Status QueueEmpty(SqQueue& q)
{
	if (q.front=q.rear=0)return TRUE;
	return FALSE;
}

typedef struct BTNode
{
	ElemType data;
	struct BTNode* lchild, * rchild;
}*BiTree;

void LevelOrder(BiTree b)
{
	BTNode* p;
	SqQueue qu;
	InitQueue(qu);
	EnQueue(qu, b);
	while (!QueueEmpty(qu))
	{
		DeQueue(qu, p);
		cout << p->data << endl;
		if (p->lchild != NULL)EnQueue(qu, p->lchild);
		if (p->rchild != NULL)EnQueue(qu, p->rchild);
	}
	
}
```

## 4.2二叉树的建立

### 4.2.1按先序遍历序列建立二叉树的二叉链表

![image-20231114171059619](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231114171059619.png)

![image-20231114172913274](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231114172913274.png)

```c++
Status CreateBiTree(BiTree& T)
{
	char ch;
	cin >> ch;
	if (ch == '#')T = NULL;
	else
	{
		if (!(T = new BTNode))exit (OVERFLOW);
		T->data = ch;
		CreateBiTree (T->lchild);
		CreateBiTree (T->rchild);
	}
}
```













# TIPS

计算机做**加减法**的速度要远高于**乘除法**。

![image-20230828134831181](C:/Users/龚曦/AppData/Roaming/Typora/typora-user-images/image-20230828134831181.png)

i++效率比++i低

![image-20231018121708476](https://tuchuang1-1.oss-cn-beijing.aliyuncs.com/D:/picgo/image-20231018121708476.png)