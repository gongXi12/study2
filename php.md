# 一.php语法初步

## 1.php代码标记

脚本标记：<script language="php">php 代码</script>

标准标记：<?php php 代码?>

## 2.php注释

行注释：//或#。

块注释：/*：直到 */出现之前，全部都是注释。

## 3.php语句分隔符

分号 ;

php中标记结束符?>有自带语句结束符的效果，最后一行php可以没有语句结束符，但不推荐这样做。

# 二.变量

php中所有变量都要使用"$"符号

**删除变量**：unset(变量名字)

## 1.变量命名规则

- php中变量名字必须以“$”符号开始
- 名字由字母、数字和下划线“_”构成，但是不能以数字开头
- 在php中允许中文变量 （但不建议使用）

## 2.预定义变量

提前定义的变量，系统定义的变量，存储许多需要用到的数据(预定义变量都是数组)

​		$_GET：获取所有表单以get方式提交的数据

​		$_POST：POST提交的数据都会保存在此

​		$_REQUEST：GET和POST提交的都会保存

​		$GLOBALS：PHP中所有的全局变量

​		$_SERVER：服务器信息

​		$_SESSION：session会话数据

​		$_COOKIE：cookie会话数据

​		$_ENV：环境信息

​		$_FILES：用户上传的文件信息

## 3.可变变量

如果一个变量保存的值刚好是另外一个变量的名字，那么可以直接通过访问一个变量得到另外一个变量的值：在变量前面再多加一个$符号。

```php
<?php

$a='b';

$b='bb';

echo $$a;//输出bb
```

## 4.变量传值

将一个变量复制给另外一个变量：变量传值

变量传值一共有两种方式：值传递，引用传递

**值传递**：将变量保存的值复制一份，然后将新的值给另外一个变量保存(两个变量没有关系)

**引用传递**：将变量保存的值所在的内存地址，传递给另外一个变量：两个变量指向同一块内存空间(两个变量是同一个值)

​				

```php
	$新变量=&$老变量
```



在内存中，通常有以下几个分区：

​		栈区：程序可以操作的内存部分(不存数据，运行程序代码)，少但是快

​		代码段：存储程序的内存部分(不执行)

​		数据段：存储普通数据(全局区和静态区)

​		堆区：存储复杂数据，大但是效率低

过程

1. 代码装载：从脚本文件中将代码读取出来，进行编译，将编译的结果存放到代码段(字节码)
2. 代码执行：从代码段中一行一行的执行代码
3. 脚本结束

# 三.常量

const/constant，是一种在程序运行过程中，不可改变的量(数据)

常量一点定义，通常数据不可改变(用户级别)

**在定义的时候必须赋值**

## 1.常量定义形式和使用形式

php中常量有两种定义方式(5.3之后才有两种)

1.使用定义常量的函数:define('常量名',常量值);

2.    5.3之后才有的：const 常量名=值;

### 常量名字的命名规则

1. 常量不需要使用"$"符号，一旦使用系统就会认为是变量
2. 常量的名字组成由字母、数字和下划线组成，不能以数字开头
3. 常量的名字通常是以大写字母为主(与变量以示区别)
4. 常量命名的规则比变量要松散，可以使用一些特殊字符，该方式只用使用define定义

```php
define('-_-','smile');

const -_- = 'smile';//报错
```

**同样输出常量遇到特殊符号时**

​		不能直接 echo 常量名;

​		要 echo constant('常量名');

注意细节：

1. define和const定义的常量是有区别：在与访问权限区别
2. 定义常量通常不区分大小写，但是可以区分，可以参照define函数的第三个参数(大小写敏感开关)(true or false，默认为false)

## 2.系统常量

系统帮助用户定义的常量，用户可以直接使用

**常用的几个系统常量**

​		PHP_VERSION：PHP版本号

​		PHP_INT_SIZE：整形大小

​		PHP_INT_MAX：整型能表示的最大值(PHP中整型是允许出现负数：带符号)

在PHP中还有一些特殊的常量，他们有双下划线开始+常量名+双下划线结束，这种常量称之为系统魔术常量：魔术常量的值通常会跟着环境变化，但是用户改变不了

### 系统魔术常量

**(省略双下划线)**

​		DIR：当前被执行的脚本所在电脑的绝对路径

​		FILE：当前被执行的脚本所在电脑的绝对路径(带自己文件的名字)

​		LINE：当前所属的行数

​		NAMESPACE：当前所属的命名空间

​		CLASS：当前所属的类

​		METHOD：当前所属的方法

# 四.数据类型

在php中指的是存储的数据本身的类型，而不是变量的类型。PHP是一种弱类型语言，变量本身没有数据类型。

## 1.PHP的八种数据类型

php中，数据分为**三大类八小类：**

**简单(基本)数据类型：4个小类**

​		整型：int/integer，系统分配4个字节存储，表示整数类型(有前提)

​		浮点型：float/double，8个字节存储，表示小数或者整型存不下的整数

​		字符串型：string，系统根据实际长度分配，表示字符串(引号)

​		布尔类型：bool/boolean，表示布尔类型，只有两个值：true和false



**复合数据类型：2个小类**

​		对象类型：object，存放对象(面向对象)

​		数组类型：array，存储多个数据(一次性)



**特殊数据类型：2个小类**

​		资源类型：resource，存放资源数据（php外部数据，如数据库、文件）

​		空类型：NULL，只有一个值就是NULL（不能运算）

## 2.类型转换

(1).**自动转换**：系统根据需求自己判定，自己转换（用的比较多，效率偏低）

(2).**强制（手动）转换**：认为根据需要的目标类型转换



在转换过程中，用的比较多的就是转布尔类型（判断）和转数值类型（算术运算）

其他类型转布尔类型：true或者false，在php中比较少类型转换变成false



其他类型转数值的说明

1. 布尔true为1，false为0；
2. 字符串转数值有自己的规则

2.1 以字母开头的字符串，永远为0

2.2 以数字开头的字符串，取到碰到字符串位置（不会同时包含两个小数点）

## 3.类型判断

通过一组类型判断函数，来判断变量，最终返回这个变量所保存数据的数据类型：是一组以is_开头后面跟类型名字的函数：is_XXX（变量名）

**Bool类型不能用 echo 来查看，可以使用 var_dump 结构查看**

Var_dump（变量1，变量2...）

​		还有一组函数可以用来获取以及设定数据（变量）的类型

------

Gettype（变量名）：获取类型，得到的是该类型对应的字符串

Settype（变量名，类型）：设定数据类型，与强制转换不同

​		1、强制转换（类型）变量名，是对数据值复制的内容进行处理（不会处理实际存储的内容）

​		2、settype会直接改变数据本身

## 4.整数类型

4个字节存储数据，在php中默认是有符号类型（区分正负数）

在php中提供了四种整型的定义方式：十进制定义，二进制定义，八进制定义和十六进制定义

**默认的php输出数值都会自动转换成10进制输出**

而且php中提供了很多**函数**去转换：

Decbin()：十进制转二进制

Decoct()：十进制转八进制

等等

## 5.浮点类型

小数类型以及超过整型所能存储范围的整数（不保证精度），精度范围大概在15个有效数字左右。

浮点型定义有两种方式：

```php
$f=1.23;

$f=1.23e10;//科学计数法
$f=PHP_INT_MAX+1;//整形超过自身存储的大小之后会用浮点型存储
```

尽量不要用浮点数做精确判断，在计算机中凡是小数基本上都存的不准确。

## 6.布尔类型

true和false

在进行某些数据判断的时候，**需要特别注意类型转换**

​		Empty()：判断数据的值是否为“空”，不是NULL，如果为空返回true，不为空返回false

​		Isset()：判断数据存储的变量本身是否存在，存在变量返回true，不存在返回false

# 五.运算符

## （一）赋值运算符

赋值运算：符号是“=”，表示将右边的结果（可以是变量、数据、常量和其他匀速出来的结果），保存到内存的某个位置，然后将位置的内存地址赋值各给左侧的变量（常量）。

## （二）算术运算符

加减乘除，取余

除法和取余的被除数不能为0

## （三）比较运算符

比较两个数据的大小，或者两个内容是否相同。返回的结果都是布尔类型。

多一个**全等于**。

​		===：全等于，左边与右边相同，大小以及数据的类型都要相同

​		!==：不全等于，只有大小或者类型不同

```php
$a='123';

$b=123

echo a==b

echo a===b
```

## （四）逻辑运算符

**&&逻辑与，||逻辑或，！逻辑非**

逻辑与和逻辑或又称之为**短路运算**：如果第一个表达式结果已经满足条件了，那么就不会运算逻辑运算符后面的表达式。

写代码时，**尽量将出现概率最高的表达式放在第一位。**

## （五）连接运算符

php中将多个字符串拼接的一种符号

​		**.** ：将两个字符串连接到一起

​		**.=** ：复合运算，将左边的内容与右边的内容连接起来，然后重新赋值给左边变量

A.=b === A =A.b

## （六）错误抑制符

php中有一些错误可以提前预支，但是这些错误可能无法避免，但是又不希望报错给用户看，这时可以使用错误抑制符处理。

​		**@**：在可能出错的表达式前加@即可。

## （七）三目运算符

三目运算：有三个表达式参与的运算（简单的分支结构缩写）

语法格式：

**表达式1 ？ 表达式2 ：表达式3;**

三目运算可以进行复合三目运算。

## （八）自操作运算符

++，--

# 六.分支结构

## （一）if分支

如果条件比较单一，会采用elseif复合方式

如果判断条件不一致，建议使用嵌套语法（不宜有太多嵌套）

## （二）switch分支

# 七.循环结构

​		**变量前加$**

## （一）for循环

```php
<?php

for($i=1;$i<2;$i++)//变量前要加$

{

}
```

## （二）while循环和do..while循环

## （三）循环控制

coutinue，break

## （四）流程控制替代语法

php一般和html嵌套使用，而php中的大括号非常不美观。**前括号用冒号代替，后括号用end+对应的起始标记替代**

```php
for(;;){} === for(;;): endfor;
//endif endswitch...
```

# 八.文件包含

在一个php脚本中，去将另外一个文件(php)包含进来，去合作完成一件事情。

## （一）文件包含的作用

​		1.要么使用被包含文件中的内容，实现代码的共享（重用）：向上包含（索要）

向上包含：在当前脚本要用某个代码之前包含别的文件

​		2.要么自己有东西可以给别的文件使用，实现代码的共享（重用）：向下包含（给予）

向下包含：在自己有某个东西的时候，需要别的脚本来显示（自己代码写完之后包含其他文件）

**优点：分工协作**

## （二）文件包含四种形式

**四种形式（两种大形式）**

​		include：包含文件

​		include_once：系统会自动判断文件包含过程中，是否已经包含过（一个文件最多被包含一次）

​		require：与include相同

​		require_once：与include once相同

**包含基本语法：**

​		include '文件名字';

​		include('文件名字');

```

```

**向上包含：先包含文件，再使用文件中的内容。**

**向下包含：先准备内容，然后包含另外的文件，在另外的文件中，使用当前的内容。**

## （三）文件加载原理

**php代码的执行流程：**

1.读取代码文件（php程序）

2.编译：将php代码转换为字节码（生成opcode）

3.zendengine来解析opcode，按照字节码去进行逻辑运算

4.转换成对应的HTML代码

------

**文件加载原理：**

1.在文件加载（include或者require）的时候，系统会自动的将被包含文件中的代码相当于嵌入到当前文件中

2.加载位置：对应的文件中的代码嵌入的位置就是对应的include位置

3.在php中被包含的文件是单独进行编译的

​		php文件在编译的过程中如果出现了语法错误，那么会失败（不会执行）；但是如果被包含文件有错误的时候，系统会在执行到包含include这条语句的时候才会报错。

```

```

## （四）include和require区别

**include和include_once的区别：**

​		include系统会碰到一次，执行一次；如果对统一个文件进行多次加载，那么系统会执行多次；

​		include_once：系统碰到多次，也只会执行一次。

```

```

**require和include的区别：**

​		本质都是包含文件，唯一的区别在于包含不到文件的时候，报错的形式不一样。

include的错误级别比较轻，不会影响代码的继续执行。

require的错误级别较高，会中止代码执行。（require后面的代码）

## （五）文件加载路径

文件在加载的时候需要指定文件路径才能保证PHP正确的找到对应的文件。

**文件的加载路径包含两大类：**

### **1.绝对路径**

​		从磁盘的根目录开始（本地绝对路径）

​		windows：盘符C:/路径/php文件

​		linux：/路径/php文件

​		从网站的根目录开始（网络绝对路径）

​		/：相对于网站主机名字对应的路径

### 2.相对路径

​		从当前文件所在目录开始的路径

​		./：表示当前文件夹

​		../：上级目录（当前文件夹的上一层文件夹）



**绝对路径和相对路径的加载区别：**

1.绝对路径相对效率偏低，但是相对安全（路径不会出问题）

2.相对路径相对效率高些，但是容易出错（相对路径会发生改变）

## （六）文件嵌套包含

嵌套包含的时候就很容易出现相对路径出错的问题：相对路径会因为文件的包含而改变（./和../）：windows下面，每一个文件夹下都有.和..的文件夹。

比如father下有father.php。也包含son文件夹，son文件夹中包含son.php。

father.php中包含了son.php时，所处环境在son文件夹中，不在father文件夹中。

# 九.函数

一种语法结构，将实现某一个功能的代码块封装到一个结构中，来实现代码的重复利用。

## （一）函数定义语法

function 函数名([参数]){

​			//函数体

​			//返回值：return 结果

}

## （二）函数命名规范

1.驼峰法

2.下划线法

## （三）函数参数

1.在php中允许实参个数大于形参：函数内部不用而已

2.在php中理论上形参个数没有限制

------

​		**默认值**

default value，指的是形参的默认值，在函数定义的时候，就给形参进行一个初始赋值：如果实际调用传入的参数（实参）没有提供，那么形参就会使用定义时的值来进入函数内部参与运算。

通常默认值是用在一些，一定会有某个数据参与，但是通常可能时候某个我们知道的值。

```

```

**注意**

1.默认值的定义是放在最后边的（多个），不能左边形参有默认值，但是右边没有

## （四）引用传递

实参在调用时会将值赋值给形参，那么实际上使用的方式就是一种简单的值传递：将实参的结果（值）取出来赋值给形参：形参与外部实际传入的参数本身没有任何关联关系：只是结果一样。

**引用传递就相当于c中的指针**

基本定义语法：

function 函数名（形参1，&形参2）{

​		//函数名

}

在调用的时候，必须给引用传值的参数位置传入实际参数，而且参数本身**必须是变量**。（变量才有指向的数据的内存地址）

```

```



## （五）函数体

## （六）作用域

超全局变量：系统定义的变量。

超全局变量会将全局变量自动纳入到$GLOBALS中

而$GLOBALS没有作用域限制，所以能够帮助局部去访问全局变量：**但是必须使用数组方式**



**global关键字**：是一种在函数里面定义变量的一种方式：

​		1.如果使用global定义的变量名在外部存在（全局变量），那么系统在函数内部定义的变量直接指向外部全局变量所指向的内存空间（同一个变量）；

​		2.如果使用global定义的变量名在外部不存在（全局变量），系统会自动在全局空间（外部）定义一个与局部变量同名的全局变量

​		本质形式：在函数的内部和外部，对一个同名变量（全局和局部）使用同一块内存地址保存数据，从而实现共同拥有。



基本语法：

global 变量名；//不能赋值

变量名 = 值

```

```

## （七）静态变量

static，是在**函数内部**定义的变量，用来实现跨函数共享数据的变量。函数运行结束所有局部变量都会清空，如果重新运行一下函数，所有的局部变量又会重新初始化。**但静态变量不会被重新初始化。**



静态变量的作用是为了跨函数共享数据（同一个函数被多次调用）

## （八）可变函数

当前有一个变量所保存的值，刚好是一个函数的名字，那么就可以使用变量+()来充当函数名使用。

```

```

可变函数在使用很多系统函数的时候：需要用户在外部定义一个自定义函数，但是是需要传入到系统内部函数使用。

​		将一个用户定义的函数传入给另外一个函数（函数名）去使用的过程，称之为**回调过程**，而被传入的函数称之为**回调函数**。

## （九）匿名函数

没有名字的函数。

**基本语法：**

变量名 = function(){

}；



**调用匿名函数**：可变函数

变量保存匿名函数，本质得到的是一个对象（closure）

------

**闭包**

closure，要执行的代码块（由于自由变量被包含在代码块中，这些自由变量以及它们引用的对象没有被释放）和为自由变量提供绑定的计算环境（作用域）。

简单理解：函数内部有一些局部变量（要执行的代码块）在函数执行之后没有被释放，是因为在函数内部还有对应的函数在引用（函数的内部函数：匿名函数）

![image-20230903170340732](C:/Users/龚曦/AppData/Roaming/Typora/typora-user-images/image-20230903170340732.png)

```

```

# 十.伪类型

mixed：混合的，可以是多种php中的数据类型

number：数值的，可以是任意数值类型（整形和浮点型）

**辅助我们查看操作手册学习**

# 十一.常用系统函数

## （一）有关输出的函数

​		print()：类似与echo，本质是一种结构，返回1，可以不需要使用括号。

​		print_r()：类似于var_dump，但是更简单，不会输出数据的类型，只会输出值（**数组打印使用比较多**）

```

```

## （二）有关时间的函数

​		date()：按照指定格式对对应的时间戳（从1970年格林威治时间开始计算的秒数），如果没有指定特定的时间戳，那么就是默认解释当前时间戳。

​		time()：获取当前时间对应的时间戳。

​		micotime()：获取微秒级别的时间，常用于测试代码快慢。

​		shrtotime():按照规定格式的字符串转换成时间戳

## （三）有关数学的函数

​		max()：指定参数中最大的值

​		min()：比较两个数中较小的值

​		rand()：得到一个随机数，指定区间的随机整数

​		mt_rand()：与rand一样，只是底层结构不一样，效率比rand高（建议使用）

​		round()：四舍五入

​		ceil()：向上取整

​		floor()：向下取整

​		pow()：求指定数字的指定指数次结果

​		abs()：绝对值

​		sqrt()：求平方根

## （四）有关函数的函数

​		function_exist()：判断指定的函数名字是否在内存中存在（帮助用户不去使用一个不存在的函数，让代码的安全性更高。

​		func_get_arg()：在自定义函数中去获取指定数值对应的参数

​		func_get_args()：在自定义函数中获取所有的参数（数组）

​		func_num_args()：获取当前自定义函数的参数数量

# 十二.错误处理

系统（或者用户）在对某些代码进行执行的时候，发现有错误，就会通过错误处理的形式告知程序员。

## （一）错误分类

​		1.语法错误（parse error）

​		2.运行时错误（runtime error）

​		3.逻辑错误

## （二）错误代号

所有看到的错误代码在php中都被定义成了系统常量（可以直接使用）

### 		1.系统错误

​		E_PARSE：编译错误，代码不会执行

​		E_ERROR：致命错误，会导致代码的出错的位置断掉

​		E_WARNING：警告错误

​		E_NOTICE：通知错误

### 		2.用户错误

​		E_USER_ERROR，E_USER_WARNING，E_USER_NOTICE

### 		3.其他

​		E_ALL

## （三）错误触发

程序运行时触发：语法错误和运行时错误

人为触发：逻辑错误

**trigger_error（错误提示）**

# 十三.字符串

## （一）字符串定义语法

​		1.单引号字符串

​		2.双引号字符串

​			**引号方式：比较适合定义那些比较短（不超过一行）或者没有结构要求的字符串。**

------

​		3.nowdoc字符串：没有单引号的单引号字符串

​		4.heredoc字符串：没有双引号的双引号字符串

```php
//nowdoc
	$str = <<<'EOD'
				hello
					world
EOD;
//heredoc
	$str = <<<EOD
				hello
					world
EOD;
```

## （二）字符串转义

转义字符

**单引号字符串中能识别出/‘**

**双引号字符串不能识别**

------

**双引号中可以解析$符号，所以双引号中可以解析变量，而单引号不能**

**在双引号中解析变量时，最好给变量加上一组大括号**

------

结构化定义字符串变量的规则：

1.结构化定义字符串对应的边界符有条件：

1.1	上边界符后面不能跟任何内容

1.2	下边界符必须定格：最左边

1.3	下边界同样后面只能跟分号，不能跟任何内容

2.结构化定义字符串的内部的所有内容都是字符串本身（注释也被包含）

## （三）字符串长度

1.基本函数：strlen()：得到字符串的长度（字节为单位）

2.多字节字符串的长度问题：包含中文的长度

3.多字节字符串扩展模块：mbstring扩展

​		mbstring扩展针对的是一些关于字符统计：strlen只是针对标准交换码ASCII，mbstring会针对不同的字符集。

（四）字符串相关函数

1.转换函数：implode()，explode()，str_split()

​		implode(连接方式，数组)：将数组中的元素按照某个规则连接成一个字符串

​		explode(分割字符，目标字符串)：将字符串按照某个格式进行分割，变成数组

​		str_split(字符串，字符长度)：按照指定长度拆分字符串得到数组。

2.截取函数：trim()，ltrim()，rtrim()

​		trim(字符串[指定字符])：本身默认是用来去除两边的空格（中间不行），但是也可以指定要去除的内容，是按照指定的内容循环去除两边有的内容：直到碰到一个不是目标字符为止

​		Ltirm()：去除左边的

​		Rtrim()：去除右边的

3.截取函数：substr()，strstr()

​		substr(字符串，起始位置从0开始[长度])：指定位置开始截取字符串，可以截取指定长度（不指定到最后）

​		strstr(字符串，匹配字符)：从指定位置开始，截取到最后（可以用来去文件后缀名）

4.大小转换函数：strtolower()，strtoupper()，ucfirst()

​		strtolower()：全部小写

​		strtoupper()：全部大写

​		ucfirst()：首字母大写

5.查找函数：strpos()，strrpos()

​		strpos()：判断字符在目标字符串中首次出现的位置

​		strrpos()：字符在目标字符串中最后一次出现的位置

6.替换函数：str_replace()

​		str_replace(匹配目标，替换的内容，字符串本身)：将目标字符串中部分字符串进行替换

7.格式化函数：printf()，sprintf()

​		printf/sprintf(输出字符串有占位符，顺序占位内容)：格式化输出数据

8.其他：str_repeat()，str_shuffle()

​		str_repeat(，N)：重复某个字符串N次

​		str_shuffle()：随机打乱字符串

# 十四.数组

## （一）数组定义语法

1.使用array关键字

​		$变量 = array(元素1，元素2...)

2.使用中括号来包裹数据

​		$变量 = [元素1，元素2...]

3.隐形定义数组：给变量增加一个中括号，系统自动变成数组

​		$变量[] = 值1；//如果不提供下标也可以，系统自动生成

​		$变量[下标] = 值； //**下标可以是字母（单词）或者数字**

```

```

## （二）php数组特点

1.下标可以为整数或者字符串。

​		如果数组下标都为整数：索引数组

​		如果数组下标都为字符串：关联数组

2.不同下标可以混合存在：混合数组

3.**数组元素的顺序以放入顺序为准，跟下标无关**

4.数字下标的自增长特性：从0开始自动增长，如果中间手动出现较大的，那么后面的自增长元素从最大的值+1开始j

5.特殊值下标的自动转换

​		布尔值：true和false

​		空：NULL

6.php中数组元素没有类型限制

7.php中数组元素没有长度限制

​		**补充：php中数组是很大的数据，所以存储位置是堆区，为当前数组分配一块连续的内存**

## （三）多维数组

数组里的元素又是数组

1.二维数组

​		数组中所有的元素都是一维数组

```

```

2.多维数组

​		在第二维的数组元素中可以继续是数组，在php中没有维度限制（php本质并没有二维数组）

​		但是：不建议使用超过三维以上的数组，会增加访问的复杂度，降低访问效率

3.异形数组（不规则数组）

​		数组中的元素不规则，有普通基本变量也有数组（不常用）

## （四）数组遍历

## 1.foreach

### (1)foreach遍历语法

```php
foreach($数组变量 as [$下标 =>]$值){
    //通过$下标访问元素的下标；通过$值访问元素的值
}
```

通常如果是关联数组（字母下标），就需要下标，如果是数字下标就直接访问值

```

```

在进行数据存储时，通常二维数组不会两个维度的key下标都为数字，一般是一维为数字（无意义），二维为字符串（数据库表字段）。

在遍历时，通常只需要对一维进行遍历，二维通过下标进行访问。

### (2)foreach遍历原理

本质时数组的内部有一个指针，默认指向数组元素的第一个元素，foreach就是利用指针去获取数据，同时移动指针。

​		1.foreach会重置指针：让指针指向第一个元素

​		2.进入foreach循环：通过指针取得当前第一个元素，然后将下标取出放到对应的下标变量中（如果存在），将值取出来放到对应的值变量中（指针下移）

​		3.进入到循环内部，开始执行

​		4.重复2和3，直到在2的时候遇到指针取不到内容（指针指向数组最后）

## 2.for循环

条件：

​		(1)获取数组长度：**count函数**获取数组长度

​		(2)要求数组元素的下标是规律的数字

```

```

## （五）数组的相关函数

1.排序函数

​		sort()：顺序排序（下标重排）

​		rsort()：逆序排序

​		asort()：顺序排序（下标保留）

​		arsort()：逆序排序

​		ksort()：顺序排序，按照下标（key）

​		krsort()：逆序排序

​		shuffle()：随机打乱数组元素，数组下标会重排

2.指针函数

​		reset()：重置指针，将数组指针回到首位

​		end()：重置指针，将数组指针移到最后一位

​		next()：指针下移，取得下一个元素的值

​		prev()：指针上移，取得上一个元素的值

​		current()：获取当前指针对应的元素值

​		key()：获取当前指针对应的下标值

**注意事项：next和prev会移动指针，有可能导致指针移到离开数组，导致数组不能使用，通过next和prev不能回到正确的指针位置。只能通过end或者reset进行指针重置**

3.其他函数

​		count()：统计数组中元素的数量

​		array_push()：往数组中加入一个元素（数组后面）

​		array_pop()：从数组中取出一个元素（数组后面）

​		array_shift()：从数组中取出一个元素（数组前面）

​		array_unshift()：从数组中加入一个元素（数组前面）

​		array_reverse()：数组元素反过来

​		in_array()：判断一个元素在数组中是否存在

​		array_keys()：获取一个数组的所有下标，返回一个索引数组

​		array_values()：获取一个数组的所有值，返回一个索引数组

# 十五.算法思想

以斐波那契数列为例

## （一）递推

从前往后

```

```



## （二）递归

从后往前

```

```

